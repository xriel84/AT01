<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AT01 — Command Console</title>
<style>
  :root {
    --bg: #0a0a0f;
    --surface: #14141f;
    --border: #2a2a3a;
    --text: #e0e0e0;
    --text-dim: #888;
    --accent: #00d4aa;
    --warn: #ffaa00;
    --error: #ff4444;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'IBM Plex Mono', 'Consolas', monospace;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    padding: 1.5rem;
  }
  .demo-banner {
    background: var(--warn);
    color: #000;
    font-weight: bold;
    text-align: center;
    padding: 6px;
    font-size: 0.7rem;
    letter-spacing: 2px;
    margin-bottom: 1rem;
    display: none;
  }
  .mode-badge {
    display: inline-block;
    padding: 2px 8px;
    font-size: 0.65rem;
    font-weight: bold;
    letter-spacing: 1px;
    border: 1px solid;
    margin-left: 0.5rem;
  }
  .mode-badge.dryrun { border-color: var(--accent); color: var(--accent); }
  .mode-badge.offline { border-color: var(--warn); color: var(--warn); }
  .mode-badge.template { border-color: #0af; color: #0af; }
  .mode-badge.ollama { border-color: #c78fff; color: #c78fff; }
  header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    flex-wrap: wrap;
    gap: 0.5rem;
  }
  h1 { font-size: 1.2rem; display: inline; }
  .input-area {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }
  #commandInput {
    flex: 1;
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 10px 14px;
    font-family: inherit;
    font-size: 0.85rem;
  }
  #commandInput:focus { outline: none; border-color: var(--accent); }
  .btn {
    background: var(--surface);
    border: 1px solid var(--accent);
    color: var(--accent);
    padding: 10px 20px;
    cursor: pointer;
    font-family: inherit;
    font-size: 0.8rem;
    transition: background 0.2s;
  }
  .btn:hover { background: #00d4aa22; }
  .btn:disabled { opacity: 0.4; cursor: not-allowed; }
  .presets {
    display: flex;
    gap: 6px;
    margin-bottom: 1.5rem;
    flex-wrap: wrap;
  }
  .preset {
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text-dim);
    padding: 4px 10px;
    font-size: 0.7rem;
    cursor: pointer;
    font-family: inherit;
  }
  .preset:hover { border-color: var(--accent); color: var(--text); }
  .history { display: flex; flex-direction: column; gap: 1rem; }
  .entry {
    background: var(--surface);
    border: 1px solid var(--border);
    padding: 1rem;
  }
  .entry-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 0.5rem;
    flex-wrap: wrap;
    gap: 0.3rem;
  }
  .entry-cmd {
    font-size: 0.8rem;
    color: var(--accent);
  }
  .entry-badges {
    display: flex;
    gap: 4px;
    align-items: center;
  }
  .entry-meta {
    font-size: 0.65rem;
    color: var(--text-dim);
    margin-bottom: 0.75rem;
  }
  .entry-result {
    font-size: 0.75rem;
    line-height: 1.6;
  }
  .result-ok { color: var(--accent); }
  .result-err { color: var(--error); }
  .decisions-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
    margin-top: 0.5rem;
  }
  .decision-card {
    background: #0d0d18;
    border-left: 3px solid var(--accent);
    padding: 8px 12px;
    font-size: 0.75rem;
  }
  .decision-card.status-failed { border-left-color: var(--error); }
  .decision-card.status-skipped { border-left-color: var(--text-dim); }
  .decision-type {
    font-size: 0.65rem;
    font-weight: bold;
    letter-spacing: 1px;
    color: var(--accent);
    text-transform: uppercase;
    margin-bottom: 4px;
  }
  .decision-card.status-failed .decision-type { color: var(--error); }
  .decision-summary { color: var(--text); }
  .decision-params {
    color: var(--text-dim);
    font-size: 0.65rem;
    margin-top: 2px;
  }
  .decision-status {
    font-size: 0.6rem;
    color: var(--text-dim);
    margin-top: 2px;
  }
  .result-summary {
    display: flex;
    gap: 1rem;
    align-items: center;
    margin-bottom: 0.5rem;
    flex-wrap: wrap;
  }
  .result-count {
    font-size: 0.75rem;
    padding: 2px 8px;
    border: 1px solid;
  }
  .result-count.ok { border-color: var(--accent); color: var(--accent); }
  .result-count.fail { border-color: var(--error); color: var(--error); }
  .result-count.skip { border-color: var(--text-dim); color: var(--text-dim); }
  .status-line {
    font-size: 0.7rem;
    color: var(--text-dim);
    margin-bottom: 1rem;
    display: flex;
    gap: 1rem;
  }
  .back-link {
    font-size: 0.75rem;
    color: var(--text-dim);
    text-decoration: none;
  }
  .back-link:hover { color: var(--accent); }
  .spinner {
    display: inline-block;
    width: 12px; height: 12px;
    border: 2px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
    margin-right: 6px;
    vertical-align: middle;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
</style>
</head>
<body>
  <div class="demo-banner" id="demoBanner">DEMO MODE — RESOLVE NOT CONNECTED</div>
  <header>
    <div>
      <a href="/frontend/index.html" class="back-link">Dashboard</a>
      <h1>Command Console</h1>
      <span class="mode-badge dryrun">DRY-RUN</span>
      <span class="mode-badge offline" id="resolveStatus" style="display:none">RESOLVE OFFLINE</span>
    </div>
  </header>

  <div class="status-line" id="statusLine"></div>

  <div class="input-area">
    <input type="text" id="commandInput" placeholder="Type a command... (e.g., add chapter markers)" />
    <button class="btn" id="sendBtn" onclick="sendCommand()">SEND</button>
  </div>

  <div class="presets">
    <button class="preset" onclick="usePreset('remove silences over 2 seconds')">Remove silences</button>
    <button class="preset" onclick="usePreset('add markers at chapter boundaries')">Add chapter markers</button>
    <button class="preset" onclick="usePreset('color code clips by speaker')">Color code speakers</button>
    <button class="preset" onclick="usePreset('create subclips from chapters')">Create subclips</button>
    <button class="preset" onclick="usePreset('set timeline to 24fps')">Set 24fps</button>
  </div>

  <div class="history" id="history"></div>

<script>
let commandHistory = [];

function usePreset(cmd) {
  document.getElementById('commandInput').value = cmd;
  document.getElementById('commandInput').focus();
}

async function sendCommand() {
  const input = document.getElementById('commandInput');
  const cmd = input.value.trim();
  if (!cmd) return;

  const btn = document.getElementById('sendBtn');
  btn.disabled = true;
  btn.textContent = 'SENDING...';
  input.value = '';

  const entry = { command: cmd, time: new Date().toISOString(), result: null, error: null, durationMs: 0 };
  const t0 = performance.now();

  try {
    const resp = await fetch('/api/resolve/command', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ command: cmd, mode: 'dry-run' })
    });
    entry.durationMs = Math.round(performance.now() - t0);
    const data = await resp.json();
    if (resp.ok) {
      entry.result = data;
    } else {
      entry.error = data.detail || data;
    }
  } catch (err) {
    entry.durationMs = Math.round(performance.now() - t0);
    entry.error = { message: 'Server unreachable: ' + err.message };
  }

  commandHistory.unshift(entry);
  renderHistory();
  btn.disabled = false;
  btn.textContent = 'SEND';
}

function describeDecision(d) {
  switch (d.type) {
    case 'add_marker':
      return 'Add ' + esc(d.color || '') + ' marker "' + esc(d.name || '') + '" at frame ' + d.frame_in;
    case 'set_clip_color':
      return 'Set clip ' + esc(d.entry_filename || '') + ' color to ' + esc(d.color || '');
    case 'create_subclip':
      return 'Create subclip "' + esc(d.subclip_name || '') + '" (frames ' + d.frame_in + '–' + d.frame_out + ')';
    case 'add_to_timeline':
      return 'Add ' + esc(d.entry_filename || '') + ' to track ' + (d.track_index || 1) + ' (frames ' + d.frame_in + '–' + d.frame_out + ')';
    default:
      return esc(d.type || 'unknown') + ': ' + esc(JSON.stringify(d));
  }
}

function decisionParams(d) {
  const parts = [];
  if (d.entry_filename) parts.push('file: ' + d.entry_filename);
  if (d.note) parts.push('note: ' + d.note);
  if (d.target_bin) parts.push('bin: ' + d.target_bin);
  if (d.target_timeline) parts.push('timeline: ' + d.target_timeline);
  if (d.marker_target && d.marker_target !== 'timeline') parts.push('target: ' + d.marker_target);
  if (d.duration && d.duration > 1) parts.push('duration: ' + d.duration + ' frames');
  return parts.join(' | ');
}

function methodBadge(method) {
  if (!method) return '';
  if (method === 'template' || method.startsWith('template'))
    return '<span class="mode-badge template">TEMPLATE</span>';
  if (method === 'ollama' || method === 'ollama_nlp')
    return '<span class="mode-badge ollama">AI INTERPRETED</span>';
  if (method === 'direct')
    return '<span class="mode-badge dryrun">DIRECT</span>';
  return '<span class="mode-badge dryrun">' + esc(method.toUpperCase()) + '</span>';
}

function renderHistory() {
  const container = document.getElementById('history');
  container.innerHTML = '';
  commandHistory.forEach(entry => {
    const div = document.createElement('div');
    div.className = 'entry';

    let resultHtml = '';
    if (entry.error) {
      const errMsg = typeof entry.error === 'string' ? entry.error :
        entry.error.error || entry.error.message || JSON.stringify(entry.error);
      resultHtml = '<div class="result-err">Error: ' + esc(errMsg) + '</div>';
    } else if (entry.result) {
      const r = entry.result;
      const decisions = (r.plan && r.plan.decisions) || [];
      const res = r.results || {};

      // Summary counts
      let summaryHtml = '<div class="result-summary">';
      if (res.succeeded !== undefined) summaryHtml += '<span class="result-count ok">' + res.succeeded + ' planned</span>';
      if (res.failed > 0) summaryHtml += '<span class="result-count fail">' + res.failed + ' failed</span>';
      if (res.skipped > 0) summaryHtml += '<span class="result-count skip">' + res.skipped + ' skipped</span>';
      summaryHtml += '</div>';

      // Decision cards
      let cardsHtml = '';
      if (decisions.length > 0) {
        cardsHtml = '<div class="decisions-list">';
        decisions.forEach((d, i) => {
          const detail = (res.details && res.details[i]) || {};
          const statusClass = detail.status === 'failed' ? ' status-failed' :
            detail.status === 'skipped' ? ' status-skipped' : '';
          cardsHtml +=
            '<div class="decision-card' + statusClass + '">' +
              '<div class="decision-type">' + esc(d.type || 'unknown') + '</div>' +
              '<div class="decision-summary">' + describeDecision(d) + '</div>' +
              (decisionParams(d) ? '<div class="decision-params">' + esc(decisionParams(d)) + '</div>' : '') +
              (detail.message ? '<div class="decision-status">' + esc(detail.status + ': ' + detail.message) + '</div>' : '') +
            '</div>';
        });
        cardsHtml += '</div>';
      } else {
        cardsHtml = '<div style="color:var(--text-dim);font-size:0.75rem;margin-top:4px">No decisions generated (check library data or Resolve connection)</div>';
      }

      resultHtml = summaryHtml + cardsHtml;
    }

    const timingStr = entry.durationMs ? entry.durationMs + 'ms' : '';
    div.innerHTML =
      '<div class="entry-header">' +
        '<div class="entry-cmd">&gt; ' + esc(entry.command) + '</div>' +
        '<div class="entry-badges">' +
          (entry.result ? methodBadge(entry.result.translation_method) : '') +
          (timingStr ? '<span style="font-size:0.6rem;color:var(--text-dim)">' + timingStr + '</span>' : '') +
        '</div>' +
      '</div>' +
      '<div class="entry-result">' + resultHtml + '</div>';
    container.appendChild(div);
  });
}

function esc(s) {
  if (s == null) return '';
  const d = document.createElement('div');
  d.textContent = String(s);
  return d.innerHTML;
}

async function checkResolve() {
  try {
    const r = await fetch('/api/resolve/status');
    const d = await r.json();
    const el = document.getElementById('resolveStatus');
    const status = document.getElementById('statusLine');
    if (d.available) {
      el.style.display = 'none';
      status.textContent = 'Resolve: ' + d.version + ' | Mode: dry-run';
    } else {
      el.style.display = 'inline-block';
      document.getElementById('demoBanner').style.display = 'block';
      status.textContent = 'Resolve: offline | Mode: dry-run (preview only)';
    }
  } catch {
    document.getElementById('resolveStatus').style.display = 'inline-block';
    document.getElementById('demoBanner').style.display = 'block';
    document.getElementById('statusLine').textContent = 'Server: unreachable | Mode: dry-run (preview only)';
  }
}

document.getElementById('commandInput').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') sendCommand();
});

checkResolve();
</script>
</body>
</html>
